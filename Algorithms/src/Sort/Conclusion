运行时间
	排序成本模型
		在研究排序算法时，需要计算比较、交换的数量。对于不交换元素的算法，需要计算访问数组的次数

额外的内存使用
	排序算法的额外内存开销和运行时间同等重要
	排序算法分为两类
		原地排序算法：除了需要函数调用所需的栈和固定数目的实例变量之外，无需额外内存
		其他排序算法：除了需要函数调用所需的栈和固定数目的实例变量之外，需要额外内存空间来储存另一份数组副本

数据类型
	在创建自己的数据类型时，需要实现Comparable接口，需要实现compareTo()方法来定义目标类型对象的自然次序
		compareTo()必须实现一个全序关系：自反性、反对称性、传递性。
		该方法实现的是主键的抽象——给出了实现了Comparable接口的任意数据类型的对象的大小顺序的定义

比较两个算法的步骤（科学步骤）
	实现并调试他们
	分析它们的基本性质
	对它们的相对性能做出猜想
	运用实验验证猜想（确定适当的输入模型  eg.这里使用的随机数组就是由SortCompare类中的timeRandomInput()方法实现的）

对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比是一个较小的常数

许多排序算法的性能都和输入模型有很大的关系，因此不同的算法适用于不同应用场景中的不同输入

研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。实现那些只能把运行时间缩短某个常数因子的改进措施可能并不值得

排序算法的复杂度
	研究复杂度步骤
		建立一个计算模型
			一般来说，研究者会尽量寻找一个和问题相关的最简单的模型
			对于排序来说，我们的研究对象是基于比较的算法，它们对数组元素的操作方法石油主键的比较决定的
			一个基于比较的算法在两次比较之间可能会进行任意规模的计算，但它只能通过主键之间的比较得到关于某个主键的信息

	没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN（斯特灵公式对阶乘函数的近似）次比较将长度为N的数组排序
	归并排序是一种渐进最优的基于比较排序的算法
		归并排序在最坏情况下的比较次数和任意基于比较的排序算法的最少比较次数都是～NlgN
		归并排序的最优性并不是结束，也不代表在实际应用中我们不会考虑其他的方法了，因为该理论还是有很多局限性的：
			归并排序的空间复杂度不是最优的
			在实践中不一定会遇到最坏情况
			除了比较，算法的其他操作（例如访问数组）也可能重要
			不进行比较也能将某些数据排序

	计算复杂度的概念可能会让人觉得很抽象，但解决可计算问题内在困难的基础性研究则不管怎么说都是非常必要的。在适用的情况下，关键在于计算复杂度会影响优秀软件的开发
		首先，准确的上界为软件工程师保证性能提供了空间，eg.平方级别排序的性能低于线性排序
		其次，准确的下界可以为我们节省很多时间，避免因不可能的性能改变而投入资源