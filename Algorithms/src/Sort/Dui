数据结构二叉堆能够很好地实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又至少要大于等于数组中的另外两个元素，以此类推

堆有序
	定义
	当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序
	命题
	根结点是堆有序的二叉树中最大结点

二叉堆
	定义
	二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）

	一棵大小为N的完全二叉树的高度为lgN向下取整

	（在下文中将二叉堆简称为堆）在一个堆中，位置k的结点的父结点的位置为k/2向下取整，而它的两个子结点的位置则分别为2k和2k+1。这样在不使用指针的情况下我们也可以通过计算数组的索引在树中上下移动

	用数组（堆）实现的完全二叉树的结构是很严格的，但它的灵活性已经足以让我们高效地实现优先队列。用它们我们将能实现对数级别的插入元素和删除最大元素的操作。利用在数组中无需指针即可沿树上下移动的便利和相关性质，算法保证了对数复杂度的性能

	对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN次比较
		两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过lgN。对于路径上的每个结点，删除最大元素需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要下沉
		对于需要大量混杂的插入和删除最大元素的典型应用来说，这意味着一个重要的性能突破。使用有序或是无序数组的优先队列的初级实现总是需要线性时间来完成其中一种操作，但基于堆的实现则能够保证在对数时间内完成它们。这种差别使得我们能够解决以前无法解决的问题。


多叉堆
	基于用数组表示的完全三叉树构造堆
	位置k的结点>=位于3k-1、3k和3k+1的结点，<=位于（k+1）/3向下取整的结点
	对于给定的d，将其修改为任意的d叉树也并不困难。我们需要在树高（logdN）和在每个结点的d个子结点找到最大者的代价之间找到折中，这取决于实现的细节以及不同操作的预期相对频繁程度

调整数组大小
	我们可以添加一个没有参数的构造函数，在insert()中添加将数组长度加倍的代码，在delMax()中添加将数组长度减半的代码。这样，算法的用例就无需关注各种队列大小的限制。当优先队列的数组大小可以调整、队列长度可以是任意值时，上文指出的对数时间复杂度上限就只是针对一般性的队列长度N而言了。


堆排序
	我们可以把任意优先队列变成一种排序方法。将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将它们按顺序删去。用无序数组实现的优先队列这么做相当于进行了一次选择排列。用基于堆的优先队列这样做等同于一种全新的排序方法——堆排序
	堆排序可以分为两个阶段。在堆的构造阶段中，我们将原始数组重新组织安排进一个堆中；然后在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。为了排序的需要，我们不在将优先队列的具体表示隐藏，并将直接使用swim()和sink()操作。这样我们就可以将需要排序的数组本身作为堆，因此无需任何额外空间

	堆的构造
		由N个给定的元素构造一个堆有多难？我们当然可以在与NlogN成正比的时间内完成这项任务，只需从左至右历遍数组，用swim()保证指针左侧的所有元素已经是一棵堆有序的完全树即可，就像连续向优先队列中插入元素一样。
		一个更聪明更高效的办法是从右至左用sink()函数构造子堆。数组的每个位置都已经是一个子堆的根结点了，sink()对于这些子堆也适用。如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink()可以将它们变成一个堆。这个过程会递归地建立起堆的秩序。开始时我们只需要扫描数组中的一半元素，因为我们可以跳过大小为1的子堆。最后我们在位置1上调用sink()方法，扫描结束。在排序的第一阶段，堆的构造方法和我们想像有所不同，因为我们的目标是构造一个堆有序的数组并使最大元素位于数组的开头（次大的元素在附近）而非构造函数结束的末尾

		用下沉操作由N个元素构造堆只需少于2N次比较、少于N次交换  P206

		堆排序的主要工作都是在第二阶段完成的。这里我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置。这个过程和选择排序有些类似（按照降序而非升序取出所有元素），但所需的比较次数要少得多，因为堆提供了一种从未排序部分找到最大元素的有效方法
